Paulo Ricardo
Megabonk-like

Resolvi utilizar esse txt como um diário do desenvolvimento para
o game. 

Espero atualizar isso ao inicio e final de cada dia de desenvolvimento.

11/11/2025 (Noite)

Conforme expliquei anteriormente ao Alefe, estou com a semana muito aterafada.
Por consequência, muito da capacidade e disponibilidade técnica está "afetada"
para a realização do teste.

Entretanto, farei da mesma maneira o teste técnico, ciente dessas limitações.

Solicitei um prazo contando a partir do dia 11/11 (terça-feira) até 18/11.
Deixei disponível para ele também um antigo teste técnico que fiz:

https://github.com/mirandafontes/Paulo-Ricardo-LIGA

Onde encontra-se o README e um diário.

Estou evitando utilizar qualquer framework ou pacote.
Os únicos pacotes que irei utilizar são os da própria Unity.

Busco a simplicidade no código em detrimento ao over-engineering.

Ao contrário do teste técnico anterior, este possui requisitos mais específicos
e um jogo com temática já presentes.

Inicialmente, defini um cenário qualquer e quis delimitar inicialmente o sistema de movimentação
do jogador.

Utilizei a física do próprio Unity, com rigidbody e um sistema de cinemachine
para garantir que a câmera siga o jogador.

Defini um scriptable responsável por conter as configurações de movimento do jogador,
o que será útil para criar outras modalidades de movimento
(além de ser possível de utilizar nos inimigos).

Existem algumas ideias já definidas em minha mente,
como o uso de classes POCO para cuidar dos inimigos e das waves.
Scriptables para descrição das curvas de spawn e similares.
Object-pool feito na própria cena (trocando o tempo de instância por um tempo de loading da scene)

Acredito que ao longo dos dias, se tornem concretas.

Gostaria de implementar o multijogador em C# cru com o DarkRift
(pois incrivelmente é mais prático e rápido de trabalhar que o PhotoNetwork)
mas vai depender da disponibilidade e avanço do projeto.

O que foi feito hoje (noite):
- Arena dummy
- PlayerMovement
- Scriptable para configuração do movimento do jogador
- Cinemachine para câmera
- Movimentação utilizando o InputActions da Unity (o que permitiria um segundo jogador)

Eventualmente, com a repetição de algumas lógicas, podemos extrair 
as interfaces.

12/11/2025 (tarde)

Fiz hoje o básico de um enemy manager.
Além disso, criei um Object Pool Generic e uma classe derivada para o MonoBehaviour.

Estive pensando em adicionar um mini-console C# (similar ao de navegador) para me ajudar a debbugar e adicionar umas funcionalidades
que seria parte correspondente ao requisito de facilitar os testes dos game designers.

Isso seria facilmente feito adicionando o C# Roslyn no projeto e criando um facade para transformar o compilador
em um interpretador em tempo-real na engine. Mas ai é bônus apenas.

Utilizei o Swap-and-Pop para otimizar a busca e uso da lista de objetos no EnemyManager, evitando métodos custosos
do LINQ. Salvando o index que representa determinado EnemyController na pool.

Utilizei POCO para presentar os dados atuais do inimigo.
Pretendo utilizar o Design Pattern State para abstrair o comportamento dos inimigos.

O que foi feito hoje (tarde):
- Generic Object Pool, com IPoolable e um MonoBehaviourPool
- Scripts do Enemy
    - Scriptable para atuar como design Pattern Prototype (blueprint dos inimigos)
    - EnemyData contém todas as informações em POCO do inimigo (extraídas por meio do blueprint). Representa o estado atual do inimigo.
    - EnemyController é a ponte MonoBehaviour que vai conter todas as referências aos componentes da Unity. Vai utilizar classes POCO para gerenciar comportamento.
    - EnemyType é um enum contendo os tipos de inimigos. Serve atualmente apenas para uma diferenciação mais adequada no scriptable.
    O ideal seria remover, pois assim, a adição de inimigos novos depende de recompilar o código, invés de adicionar apenas mais conteúdo em
    um possível sistema de Addressables, mas enfim.

Pretendo construir o controlador de spawn utilizando animation curves para definir as curvas
de spawn dos inimigos.

(noite)
Vim adaptar os scripts para testar o EnemyController e EnemyManager.
Quero testar se o visual se alterna de maneira adequada e se o EnemyManager gerencia corretamente a pool.

Infelizmente o maior desgosto da noite está sendo o enum com o tipo de inimigo.
Ao mesmo tempo que gostaria de removê-lo, pois isso dificulta a adição de conteúdo,
preciso de algo mais consistente que uma string para uma "cola" mínima.

O ideal seria realizar um mapping utilizando um scriptable para isso. O mapping seria também o id do addressable,
o que tornaria tudo identificável por um id único e consistente para todo o processo, mas enfim.

Adicionei uns ContextMenu.
O ideal seria realizar um script e rodar junto com o TestRunner, criando uma série de testes unitários.

Ou, ainda, criar um script MonoBehaviour terceiro responsável contendo uma UI inteira para testar e alterar os parametros.
Esse script seria utilizado por devs e game designers no geral.

Algo legal da estrutura que criei é que é possível ter EnemyManagers especializados em um único tipo de inimigo.
Ou seja, podemos um EnemyManager que dê spawn apenas de esqueletos, ou de harpia, ou de tudo misturado.
Divide-To-Conquer.

13/11/2025 (manhã)

Vou implementar um pequeno Strategy Pattern para a movimentação, "limpando" o EnemyManager dessa responsabilidade direta.
Isso vai permitir que cada EnemyManager tenha um modo de movimentação para seus inimigos no futuro.
O script atual de movimentação será um simples de perseguição direta ao usuário, evitando alguns obstáculos.

Além disso, vou dividir o cálculo da atualização da movimentação dos inimigos ao longo dos frames.

Utilizei ScriptableObjects para separar ainda mais o comportamento. Um strategy pattern completo, com opções
para configuração diretamente no inspetor.

(tarde)

Levei mais um pouco de tempo pela tarde para adaptar o sistema de movimentação nesse design.
Fiz algumas pequenas otimizações ao utilizar layermask e tags para garantir a movimentação dos inimigos e evitar obstáculos.

Pretendo atacar de noite o WaveSpawn, para criar uma lógica de curvas de spawn.
Além disso, revisar alguams configurações de build e do compiler do Unity, buscando mais performance.

(noite)

Estou configurando o sistema do Wave. Vou utilizar um sistema de scriptables para criar as Waves junto com um sistema
de animation curves para definir o peso dos inimigos.

Revisei novamente o EnemyManager, retirando algumas lógicas e refatorando.
Retirei a lógica de arrumar uma posição para spawn, criando uma classe em específico (ISpawner e derivados).

Pretendo amanhã realizar uma UI básica para começar o jogo e testar o WaveManager, Spawner e sistemas similares.

14/11/2025 (manhã)

Antes de realizar as UI, vou configurar a Unity para otimização geral:
- Build Settings:
    - Compression Method = LZ4HC
    - Build utilizando IL2CPP
    - C++ Compiler Configuration = Master
    - Stacktrace desativada para warnings e asserts
    - Diagnostic Data desativado
    - Lightmap e HDR enconding = Normal quality
    - Preload Assets = EnemyController (prefab do inimigo)

- Physics Settings:
    - Otimização da Matrix de colisão

- Quality Settings:
    - VSync Count = Don't sync
    - Global MipMap = Half Resolution
    - Anisotropic Textures = Desabilitado

- Universal Render Pipeline:
    - Depth-texture = Desativado
    - Anti-aliasing = Desativado
    - HDR = Desativado
    - Shadow Resolution = 1024
    - Additional Lights -> Per Vertex -> Per Object Limit = 2
    - Shadows -> Cascade count -> 2
    - Soft shadows -> Quality -> Medium

- Time:
    - Aumento do intervalo de atualização do Fixed Update

Além disso, fiz uma rápida refatoração no EnemyManager, encapsulando algumas lógicas em métodos (Clean Code)

(tarde)

Algo que estive pensando em fazer é um conjunto de ferramentas do editor
para poder facilitar a criação e adição de inimigos, movimentos, algortimos de perseguição e similares.

E, além disso, novamente recorrer a construção de um script terceiro para manipular os componentes
Algo como um Swagger, para o game designer.

(noite)
Meu computador quebrou.
A 2060 deve ter tomado um curto.
Por sorte, tinha o repositório remoto no github.
Estou tentando consertar o computador, e caso dê errado, vou procurar outro para terminar.

15/11/2025 (manhã)

Tentei reparar o computador limpando a 2060 com limpa-contato e afins.
Removi as peças, limpei e coloquei de novo, nada.
Vou procurar outro computador para terminar o teste.

(tarde)
Consegui arrumar um computador extra. Após o almoço (13h), voltei a codar.
Por consequência do prazo e do atraso devido ao computador quebrado, resolvi simplificar algumas concepções que tinha.

Implementei o PlayerStats, que é uma classe POCO para controlar os stats do jogador, subir de nível e atualizar status base.
Além disso, essa mesma clase é responsável por receber os efeitos de itens, multiplicar pelo valor base e retornar o valor atualizado.
Atua de maneira similar ao EnemyData, mas com mais funções.

Refatorei o PlayerMovement para utilizar um PlayerStats para obter a velocidade máxima atual do player.

Criei um scriptable para conter AnimationCurves, que seriam utilizadas por game designers para definir uma série de comportamentos.
Exemplo: exp total acumulada por nível, incremento de valores base do jogador por nível, e similares.

Uma ferramenta do editor para preencher isso de uma maneira mais rápida (principalmente os que tem comportamento linear).

PlayerController atua como classe monobehaviour orquestradora.
Ela é inicializada antes das outras classes também (modificando o tempo de inicialização dos scripts no Project Settings).

Defini uma interface e um conjunto básicos de scripts para as armas e os itens do jogador.
Utilizei um design similar ao Strategy Pattern + Scriptable + DI + Abstract class para definir a estrutura das armas e itens.
(parecido com o utilizado para definir um script de perseguição)

Não utilizei os scriptables das AnimationCurves no sistema de armas pois quero que seja mais explícito ao designer o fine-tuning de cada arma.
Ao contrário do PlayerStats, que é um crescimento mais linear e centrado.
(embora seja facilmente conversível os tipos)

O sistema de armas inclui Weapons, Items e WeaponEffect.
Weapon e IWeaponEffect andam de mãos dadas com o WeaponBlueprint.
Um WeaponEffect é implementado enquanto POCO e a partir de uma interface IWeaponEffect.
WeaponBlueprint é o SO concreto de uma arma. WeaponData é a classe POCO com os dados *atuais* da arma.
WeaponEffect vai para WeaponBlueprint como um scriptable, onde o algortimo de efeito é extraído.
Vou extrair um WeaponAttack para seguir estratégia similar.

Adicionei o sistema de WeaponAttack.
Estou utilizando Physics.*NonAlloc para identificar, a partir de um vector3 os inimigos em determinado range
e aplicar o ataque em cada um deles, por meio da interface IDamageable

Fiz uma adequação na interface, removendo o gameobject de origem da API.

Fiz uma adição do Enemy no LayerMask da Unity, e adicionei como uma das layers para evitar no algortimo de perseguição.
Com isso, os inimigos também se evitam no algoritmo.

16/11/2025 (manhã)

Fiz algumas correções menores e adequações no EnemyManager, PlayerManager e afins.
Criei o PlayerWeapon e deixei "hard-coded" as armas do jogador, uma espada e um arco.

Tive que fazer diversas simplificações devido ao tempo e ao atraso do computador quebrado.

Pela noite devo implementar um EventBus para evitar criar mais estruturas, garatindo que
os scripts se comuniquem pelo barramennto.

(noite)
Implementei o básico de uma HUD e algumas UI's
Fiz o EventBus com uma struct para comunicação de eventos entre scripts sem um acomplamento direto
Corrigi alguns bugs menores e adicionei umas API's que estavam faltando.

17/11/2025 (manhã)

Simplifiquei mais sistemas devido ao tempo.
Fiz a tela de GameOver e fiz uns bindings de alguns eventos
para terminar o jogo.

O GameOver infelizmente está dando um reload na scene, e não fazendo um soft-reboot nos sistemas
(o que é possível na infra-estrutura atual).

Dado o tempo e a quantidade de tarefas alheias que tenho na semana, infelizmente não serei
capaz de concluir o projeto com os feedbacks e gráficos adequados.
Ele está em torno de 90% concluído, faltando basicamente uns feedbacks e alguns polimentos no geral.
Os sistemas estão em sua totalidade, concluídos.


Na estrutura que criei, consigo instanciar 500 inimigos e atualizar 250 por FixedUpdate.
Para garantir 60FPS, o frame tem que ter no máximo 16.67ms (1/60).

Vamos as contas: atualizando 250 inimigos por frame fixed update, com 500 inimigos ao mesmo tempo, e considerando a taxa padrão da Unity de 20ms.
Ou seja, a Unity tenta executar o FixedUpdate 50 vezes por segundo.
(a taxa de atualização do FixedUpdate no projeto foi aumentada)

Temos (estimativa): 500/250 = 2 frames do FixedUpdate para atualizar tudo.
2 frames * 20 ms = 40ms para atualizar todos os inimigos.
1 / 0.040 = 25 vezes um inimigo é atualizado por segundo.

A taxa padrão de atualização da física no Unity (20ms) é tratada como um "orçamento" para uso.
Ou seja, atualizar os inimigos deve levar, no máximo, 20ms. Qualquer coisa além disso, o desempenho começa a degradar.

Ao observar no profiler (ryzen 7 2700x + RX 6700XT), temos os picos do
fixed update levando 13.54ms.

Ao verificar o tempo total de render da main thread, para um frame, observamos que
o PlayerLoop está com 16,81ms, indicando que está com cerca de 59.49FPS.

Ou seja, estamos dentro do orçamento proposto para uma situação muito extrema.
Utilizando o dobro de inimigos do teste (500 no total), e atualizando todos em 2 frames, temos uma média de 60FPS.


Alguns mais testes simples me fizeram também identificar um gargalo no algortimo de Pursuit.
Fiz otimizações no SimplePursuit, buscando evitar uma situação de gargalo onde os inimigos acabam se empilhando ao redor do player.
Fiz o CalculateSeparation para evitar esse empilhamento, mas acredito que é negligenciável em jogos assim, devido a qtd de inimigos,
e também um short-cut, caso o inimigo esteja muito próximo do jogador, para interromper o movimento.

Infelizmente, não tenho mais tempo hábil para implementar de maneira adequada um sistema de items completos.
O sistema, core em si, é extremamente maleável e expansível.
Entretanto, as pontes MonoBehaviour não são.
Fiz de uma maneira simplificada e hard-coded devido ao tempo.

Devo produzir um readme agora pelo resto do dia, explicando todo o processo.