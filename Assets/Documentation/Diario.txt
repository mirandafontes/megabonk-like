Paulo Ricardo
Megabonk-like

Resolvi utilizar esse txt como um diário do desenvolvimento para
o game. 

Espero atualizar isso ao inicio e final de cada dia de desenvolvimento.

11/11/2025 (Noite)

Conforme expliquei anteriormente ao Alefe, estou com a semana muito aterafada.
Por consequência, muito da capacidade e disponibilidade técnica está "afetada"
para a realização do teste.

Entretanto, farei da mesma maneira o teste técnico, ciente dessas limitações.

Solicitei um prazo contando a partir do dia 11/11 (terça-feira) até 18/11.
Deixei disponível para ele também um antigo teste técnico que fiz:

https://github.com/mirandafontes/Paulo-Ricardo-LIGA

Onde encontra-se o README e um diário.

Estou evitando utilizar qualquer framework ou pacote.
Os únicos pacotes que irei utilizar são os da própria Unity.

Busco a simplicidade no código em detrimento ao over-engineering.

Ao contrário do teste técnico anterior, este possui requisitos mais específicos
e um jogo com temática já presentes.

Inicialmente, defini um cenário qualquer e quis delimitar inicialmente o sistema de movimentação
do jogador.

Utilizei a física do próprio Unity, com rigidbody e um sistema de cinemachine
para garantir que a câmera siga o jogador.

Defini um scriptable responsável por conter as configurações de movimento do jogador,
o que será útil para criar outras modalidades de movimento
(além de ser possível de utilizar nos inimigos).

Existem algumas ideias já definidas em minha mente,
como o uso de classes POCO para cuidar dos inimigos e das waves.
Scriptables para descrição das curvas de spawn e similares.
Object-pool feito na própria cena (trocando o tempo de instância por um tempo de loading da scene)

Acredito que ao longo dos dias, se tornem concretas.

Gostaria de implementar o multijogador em C# cru com o DarkRift
(pois incrivelmente é mais prático e rápido de trabalhar que o PhotoNetwork)
mas vai depender da disponibilidade e avanço do projeto.

O que foi feito hoje (noite):
- Arena dummy
- PlayerMovement
- Scriptable para configuração do movimento do jogador
- Cinemachine para câmera
- Movimentação utilizando o InputActions da Unity (o que permitiria um segundo jogador)

Eventualmente, com a repetição de algumas lógicas, podemos extrair 
as interfaces.

12/11/2025 (tarde)

Fiz hoje o básico de um enemy manager.
Além disso, criei um Object Pool Generic e uma classe derivada para o MonoBehaviour.

Estive pensando em adicionar um mini-console C# (similar ao de navegador) para me ajudar a debbugar e adicionar umas funcionalidades
que seria parte correspondente ao requisito de facilitar os testes dos game designers.

Isso seria facilmente feito adicionando o C# Roslyn no projeto e criando um facade para transformar o compilador
em um interpretador em tempo-real na engine. Mas ai é bônus apenas.

Utilizei o Swap-and-Pop para otimizar a busca e uso da lista de objetos no EnemyManager, evitando métodos custosos
do LINQ. Salvando o index que representa determinado EnemyController na pool.

Utilizei POCO para presentar os dados atuais do inimigo.
Pretendo utilizar o Design Pattern State para abstrair o comportamento dos inimigos.

O que foi feito hoje (tarde):
- Generic Object Pool, com IPoolable e um MonoBehaviourPool
- Scripts do Enemy
    - Scriptable para atuar como design Pattern Prototype (blueprint dos inimigos)
    - EnemyData contém todas as informações em POCO do inimigo (extraídas por meio do blueprint). Representa o estado atual do inimigo.
    - EnemyController é a ponte MonoBehaviour que vai conter todas as referências aos componentes da Unity. Vai utilizar classes POCO para gerenciar comportamento.
    - EnemyType é um enum contendo os tipos de inimigos. Serve atualmente apenas para uma diferenciação mais adequada no scriptable.
    O ideal seria remover, pois assim, a adição de inimigos novos depende de recompilar o código, invés de adicionar apenas mais conteúdo em
    um possível sistema de Addressables, mas enfim.

Pretendo construir o controlador de spawn utilizando animation curves para definir as curvas
de spawn dos inimigos.

(noite)
Vim adaptar os scripts para testar o EnemyController e EnemyManager.
Quero testar se o visual se alterna de maneira adequada e se o EnemyManager gerencia corretamente a pool.

Infelizmente o maior desgosto da noite está sendo o enum com o tipo de inimigo.
Ao mesmo tempo que gostaria de removê-lo, pois isso dificulta a adição de conteúdo,
preciso de algo mais consistente que uma string para uma "cola" mínima.

O ideal seria realizar um mapping utilizando um scriptable para isso. O mapping seria também o id do addressable,
o que tornaria tudo identificável por um id único e consistente para todo o processo, mas enfim.

Adicionei uns ContextMenu.
O ideal seria realizar um script e rodar junto com o TestRunner, criando uma série de testes unitários.

Ou, ainda, criar um script MonoBehaviour terceiro responsável contendo uma UI inteira para testar e alterar os parametros.
Esse script seria utilizado por devs e game designers no geral.

Algo legal da estrutura que criei é que é possível ter EnemyManagers especializados em um único tipo de inimigo.
Ou seja, podemos um EnemyManager que dê spawn apenas de esqueletos, ou de harpia, ou de tudo misturado.
Divide-To-Conquer.

13/11/2025 (manhã)

Vou implementar um pequeno Strategy Pattern para a movimentação, "limpando" o EnemyManager dessa responsabilidade direta.
Isso vai permitir que cada EnemyManager tenha um modo de movimentação para seus inimigos no futuro.
O script atual de movimentação será um simples de perseguição direta ao usuário, evitando alguns obstáculos.

Além disso, vou dividir o cálculo da atualização da movimentação dos inimigos ao longo dos frames.

Utilizei ScriptableObjects para separar ainda mais o comportamento. Um strategy pattern completo, com opções
para configuração diretamente no inspetor.

(tarde)

Levei mais um pouco de tempo pela tarde para adaptar o sistema de movimentação nesse design.
Fiz algumas pequenas otimizações ao utilizar layermask e tags para garantir a movimentação dos inimigos e evitar obstáculos.

Pretendo atacar de noite o WaveSpawn, para criar uma lógica de curvas de spawn.
Além disso, revisar alguams configurações de build e do compiler do Unity, buscando mais performance.

(noite)

Estou configurando o sistema do Wave. Vou utilizar um sistema de scriptables para criar as Waves junto com um sistema
de animation curves para definir o peso dos inimigos.

Revisei novamente o EnemyManager, retirando algumas lógicas e refatorando.
Retirei a lógica de arrumar uma posição para spawn, criando uma classe em específico (ISpawner e derivados).

Pretendo amanhã realizar uma UI básica para começar o jogo e testar o WaveManager, Spawner e sistemas similares.

14/11/2025 (manhã)

Antes de realizar as UI, vou configurar a Unity para otimização geral:
- Build Settings:
    - Compression Method = LZ4HC
    - Build utilizando IL2CPP
    - C++ Compiler Configuration = Master
    - Stacktrace desativada para warnings e asserts
    - Diagnostic Data desativado
    - Lightmap e HDR enconding = Normal quality
    - Preload Assets = EnemyController (prefab do inimigo)

- Physics Settings:
    - Otimização da Matrix de colisão

- Quality Settings:
    - VSync Count = Don't sync
    - Global MipMap = Half Resolution
    - Anisotropic Textures = Desabilitado

- Universal Render Pipeline:
    - Depth-texture = Desativado
    - Anti-aliasing = Desativado
    - HDR = Desativado
    - Shadow Resolution = 1024
    - Additional Lights -> Per Vertex -> Per Object Limit = 2
    - Shadows -> Cascade count -> 2
    - Soft shadows -> Quality -> Medium

- Time:
    - Aumento do intervalo de atualização do Fixed Update

Além disso, fiz uma rápida refatoração no EnemyManager, encapsulando algumas lógicas em métodos (Clean Code)